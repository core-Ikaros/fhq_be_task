# 计算机网络

## UDP

UDP 不保证数据包的可靠传输，它只是把应用程序传给 IP 层的数据报发送出去，但是并不能保证它们能到达目的地。开销较小，传输速度较快。

语言、视频、直播

## TCP！！！

### 三次握手（建立连接）

syn seq 客户端向服务器发送syn包

- 客户端会向服务器发送一个 TCP 数据包，其中 SYN（Synchronize Sequence Numbers，同步序列号）标志位被置为 1，表示这是一个连接请求包。
- 同时，客户端会随机生成一个初始序列号（Initial Sequence Number，ISN），假设为 `x`，并将其放在 TCP 头部的序列号字段中。
- 此时客户端进入 `SYN_SENT` 状态，等待服务器的响应。

syn ack seq 服务器向客户端发送syn+ack包

- 服务器接收到客户端的 SYN 包后，理解这是一个连接请求。服务器会为该连接分配必要的资源。
- 服务器会发送一个响应数据包，这个数据包中 SYN 和 ACK（Acknowledgment，确认）标志位都被置为 1。SYN = 1 表示服务器也同意建立连接，并且服务器也会随机生成一个自己的初始序列号，假设为 `y`，放在序列号字段中。
- ACK = 1 表示对客户端 SYN 包的确认，确认号字段的值为客户端的初始序列号 `x` 加 1，即 `x + 1`，表示服务器期望收到客户端下一个序列号为 `x + 1` 的数据包。
- 发送完这个数据包后，服务器进入 `SYN_RCVD` 状态。

ack seq 客户端向服务器发送ack包

- 客户端收到服务器的 SYN + ACK 包后，会检查确认号是否为自己的初始序列号加 1，以及 SYN 标志位是否为 1。如果检查通过，客户端会发送一个确认数据包，其中 ACK 标志位被置为 1。
- 确认号字段的值为服务器的初始序列号 `y` 加 1，即 `y + 1`，表示客户端期望收到服务器下一个序列号为 `y + 1` 的数据包。
- 序列号字段的值为客户端的初始序列号 `x` 加 1，即 `x + 1`。
- 客户端发送完这个 ACK 包后，进入 `ESTABLISHED` 状态。服务器收到这个 ACK 包后，也进入 `ESTABLISHED` 状态，此时 TCP 连接成功建立，双方可以开始进行数据传输

作用：为了防止已失效的连接请求报文段突然又传送到服务端产生错误

### 四次握手（断开连接）

fin ack seq 客户端向服务器发送fin包

- 当客户端完成数据发送，决定关闭连接时，会向服务器发送一个 TCP 数据包，其中 FIN（Finish，结束）标志位被置为 1，表示客户端已经没有数据要发送了，请求关闭连接。
- 同时，客户端会将当前的序列号 `u` 放入 TCP 头部的序列号字段。
- 发送完这个数据包后，客户端进入 `FIN_WAIT_1` 状态，开始等待服务器的确认。

ack seq  服务器向客户端发送ack包

- 服务器接收到客户端的 FIN 包后，知道客户端想要关闭连接。服务器会发送一个确认数据包，其中 ACK 标志位被置为 1，表示对客户端 FIN 包的确认。
- 确认号字段的值为客户端的序列号 `u` 加 1，即 `u + 1`，表示服务器期望收到客户端下一个序列号为 `u + 1` 的数据包（不过实际上客户端已无数据要发）。
- 服务器自己的序列号为 `v`，放入序列号字段。
- 发送完这个 ACK 包后，服务器进入 `CLOSE_WAIT` 状态。此时客户端到服务器的连接已经关闭，但服务器到客户端的连接还未关闭，服务器可能还有数据要发送给客户端。
- 客户端收到这个 ACK 包后，进入 `FIN_WAIT_2` 状态，等待服务器发送关闭连接的请求。

fin ack seq  服务器向客户端发送fin包

- 当服务器完成数据发送后，也决定关闭连接。服务器会向客户端发送一个 TCP 数据包，其中 FIN 标志位被置为 1，表示服务器也没有数据要发送了，请求关闭连接。
- 序列号为之前的 `v`，确认号依然是 `u + 1`。
- 发送完这个 FIN 包后，服务器进入 `LAST_ACK` 状态，等待客户端的最后确认。

ack seq

- 客户端收到服务器的 FIN 包后，会发送一个确认数据包，其中 ACK 标志位被置为 1。
- 确认号字段的值为服务器的序列号 `v` 加 1，即 `v + 1`，表示客户端期望收到服务器下一个序列号为 `v + 1` 的数据包（实际不会再收到）。
- 客户端自己的序列号为 `u + 1`。
- 客户端发送完这个 ACK 包后，进入 `TIME_WAIT` 状态。服务器收到这个 ACK 包后，进入 `CLOSED` 状态，此时服务器端的连接已经完全关闭。
- 客户端在 `TIME_WAIT` 状态会停留一段时间（通常是 2 倍的最大报文段生存时间，即 2MSL），以确保服务器能收到自己的 ACK 包。如果服务器没收到 ACK 包，会重发 FIN 包，客户端在 `TIME_WAIT` 状态可以再次响应。2MSL 时间过后，客户端进入 `CLOSED` 状态，至此整个 TCP 连接完全关闭。

### 场景

网络会话 文件传输 发送接收邮件 远程登录

### 如何保证可靠？

握手机制

序列号和确认机制

超时重传 

快速重传//当接收方收到一个失序的数据包时，会立即发送一个重复的 ACK 报文，告知发送方期望收到的序列号。如果发送方连续收到三个重复的 ACK 报文，就会认为对应的数据包丢失，立即重传该数据包，而不必等待定时器超时。例如，接收方按顺序收到了序列号为 1、2、4 的数据包，缺少序列号为 3 的数据包，此时接收方会连续发送三个确认号为 3 的 ACK 报文，发送方收到后会快速重传序列号为 3 的数据包。

流量控制 e.g接收方告知发送方自己的接收窗口大小为 1000 字节，那么发送方在未收到新的窗口通知之前，最多只能发送 1000 字节的数据。

高效传输 可发送多个数据包

校验和机制//TCP 在每个报文段中都包含一个校验和字段。发送方在发送数据时会计算整个报文段（包括 TCP 头部和数据部分）的校验和，并将其放在校验和字段中。接收方收到数据后，会重新计算校验和，并与报文中的校验和进行比较。如果两者不相等，说明数据在传输过程中发生了错误，接收方会丢弃该报文段，并要求发送方重传。这确保了数据的完整性。

## HTTP

超文本传输协议 基于TCP/IP 万维网通信基础

无状态特性 无状态指协议本身不记录客户端和服务器之间的通信状态，每次请求独立。可通过 Cookie、Session 等技术解决，Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，用于在客户端和服务器间传递信息；Session 则是服务器端的会话机制，通过唯一的 Session ID 来识别客户端。

请求 处理请求 返回响应 关闭连接

请求方法 get post put delete head

状态码 200 表示请求成功；404 表示请求的资源未在服务器上找到；500 表示服务器内部发生错误，无法完成请求。

版本区别 

HTTP/1.1 是目前广泛使用的版本，引入了持久连接、请求头压缩、分块传输等特性；HTTP/2 采用二进制分帧、多路复用、头部压缩等技术，进一步提高了性能和效率，可在一个 TCP 连接上同时处理多个请求和响应，减少延迟。

HTTP/3 基于 QUIC 协议，解决了 HTTP/2 在网络拥塞时的一些问题，如队头阻塞问题，提供了更好的性能和可靠性，尤其在移动网络环境下表现出色。

缓存机制 强缓存(直接从本地)和协商缓存(使用前检查是否更新)

## HTTPS

加入了SSL/TLS

1. **客户端发起请求**：客户端向服务器发送一个 `ClientHello` 消息，包含客户端支持的 SSL/TLS 版本、加密算法列表、压缩算法列表以及一个随机数 `ClientRandom`。
2. **服务器响应**：服务器收到请求后，发送 `ServerHello` 消息，选择一个 SSL/TLS 版本和加密算法，并返回一个随机数 `ServerRandom`。同时，服务器会发送自己的数字证书，证书中包含服务器的公钥。
3. **客户端验证证书**：客户端接收到服务器的证书后，会验证证书的有效性，包括证书的颁发机构、有效期、域名等信息。如果证书有效，客户端会从证书中提取服务器的公钥。
4. **生成会话密钥**：客户端生成一个预主密钥 `PreMasterSecret`，并使用服务器的公钥对其进行加密，然后发送给服务器。客户端和服务器根据 `ClientRandom`、`ServerRandom` 和 `PreMasterSecret` 生成会话密钥 `SessionKey`，用于后续的数据加密和解密。
5. **完成握手**：客户端和服务器分别向对方发送一个 `ChangeCipherSpec` 消息，表示后续的数据将使用新生成的会话密钥进行加密。然后，双方发送 `Finished` 消息，验证握手过程是否成功。

数据加密

身份验证 

完整性保护 使用mac来保证

注：HTTP 默认使用 80 端口，而 HTTPS 默认使用 443 端口

## BIO

阻塞等待连接

阻塞等待数据

开线程处理并发

耗资源

## NIO

非阻塞IO

缓冲区

通道(双向)

选择器//监听多个通道 一个线程管理多个通道 高效并发处理

epoll

## 粘包/拆包

- **粘包**：指在数据传输过程中，多个原本独立的数据包被合并成一个数据包发送到接收端。接收端在解析数据时，难以区分出各个原始数据包的边界。

原因：
TCP协议导致的缓冲和优化

Nagle算法//将小的数据包进行合并，直到达到一定的大小或者等待一段时间后再发送

接收方处理不及时

现象：

发送方依次发送了两个数据包 “Hello” 和 “World”，接收方可能会一次性收到 “HelloWorld”，难以分辨这是两个独立的数据包。

- **拆包**：指一个完整的数据包在传输过程中被分割成多个小的数据包发送到接收端。接收端需要将这些小的数据包重新组合成完整的原始数据包。

原因：

超出MTU（Maximum Transmission Unit，最大传输单元）

滑动窗口流量控制

现象：

发送方发送了一个较长的数据包 “This is a long message”，由于拆包，接收方可能先收到 “This is a ”，后续才收到 “long message”。

## 多路复用

### select

单个进程可监视的fd数量被限制，即能监听端口的大小有限。

对socket扫描是线性扫描，采用轮询方法，效率低

需要维护一个用来存放大量fd的数据结构，这样会使用户空间和内核空间在传递该结构时开销大

### poll

大量的fd数组被整体复制于用户和内核地址空间之间，而不管这样的复制是否有意义

水平触发，如果报告了fd没有被处理，那么下次poll时会再次报告该fd

### epoll

没有最大并发连接的限制，能打开的fd的上限远大于1024（1G内存上能监听10万个端口）

效率提升，不会随fd数目增加而效率下降

内存拷贝，利用mmap()文件映射内存加速与内存空间的消息传递；减少复制开销

## 序列化

序列化（Serialization）是将对象的状态信息转换为可以存储或传输的形式（如字节序列）的过程，而反序列化则是将字节序列恢复为对象的过程。

使数据持久化

网络传输

## DNS

进行域名解析

#### 类型

- **A 记录（Address Record）**：是最常见的 DNS 记录类型，用于将域名指向一个 IPv4 地址。例如，将 `example.com` 指向 `192.168.1.100`。
- **AAAA 记录**：用于将域名指向一个 IPv6 地址。随着 IPv6 的逐渐普及，AAAA 记录的使用也越来越广泛。
- **CNAME 记录（Canonical Name Record）**：用于将一个域名指向另一个域名。例如，将 `www.example.com` 指向 `example.com`，这样当用户访问 `www.example.com` 时，实际上会访问 `example.com`。
- **MX 记录（Mail Exchange Record）**：用于指定域名的邮件服务器地址。当用户发送邮件到该域名时，邮件系统会根据 MX 记录将邮件发送到指定的邮件服务器。
- **NS 记录（Name Server Record）**：用于指定域名的权威 DNS 服务器地址。当进行域名解析时，会根据 NS 记录找到对应的权威 DNS 服务器进行查询。

递归查询和迭代查询

#### 优化域名解析

CDN

配置DNS预解析

定期清理缓存

